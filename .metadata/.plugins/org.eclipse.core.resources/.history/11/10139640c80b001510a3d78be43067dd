package com.geertenvink.Bardiche;

import com.stephengware.java.glaive.GlaivePlan;
import com.stephengware.java.glaive.GlaiveRelaxedPlanBuilder;
import com.stephengware.java.glaive.GlaiveSearchNode;
import com.stephengware.java.planware.ArgumentMap;
import com.stephengware.java.planware.AxiomTree;
import com.stephengware.java.planware.State;
import com.stephengware.java.planware.ig.IntentionGraph;
import com.stephengware.java.planware.logic.Expression;
import com.stephengware.java.planware.ss.IntentionalStateSpace;
import com.stephengware.java.planware.IntentionalProblem;

public class PossibilityChecker {
	private static BardicheProblem problem;
	private static AxiomTree axiomTree;
	private static IntentionalStateSpace stateSpace;
	
	private static boolean initialized = false;
	
	public static void initialize(ArgumentMap arguments) {
		problem = arguments.get(Bardiche.PROBLEM);
		axiomTree = arguments.get(Bardiche.AXIOM_TREE);
		stateSpace = arguments.get(Bardiche.STATE_SPACE);
		
		initialized = true;
	}
	
	public static boolean test(Expression argument, State state) {
		if (!initialized)
			try {
				throw new InitializationException("PossibilityChecker used before initialization");
			} catch (InitializationException e) {
				// TODO Auto-generated catch block
				e.printStackTrace();
			}
		
		IntentionalProblem possibilityProblem = new IntentionalProblem(
				"possibilityCheckerProblem",
				problem.domain,
				problem.universe,
				state.toExpression(),
				argument);
		GlaivePlan possibilityPlan = new GlaivePlan("possibilityCheckerPlan", possibilityProblem, axiomTree);
		Evaluator evaluator = new Evaluator(stateSpace, argument);
		
		return evaluator.isPossible(possibilityPlan);
	}
	
	private class Evaluator extends GlaiveRelaxedPlanBuilder {
		public Evaluator(IntentionalStateSpace stateSpace, Expression goal) {
			super(new IntentionGraph(stateSpace), goal);
		}
		
		public boolean isPossible(GlaivePlan possibilityPlan) {
			GlaiveSearchNode node = new GlaiveSearchNode(possibilityPlan);
			
			evaluate(node);
			
			return node.isAuthorGoalAchievable();
		}
	}
	
}
